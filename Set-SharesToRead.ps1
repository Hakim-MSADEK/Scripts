param(
    $Credentials,
    [ValidateSet('Specific','All','CSV','RollBackCSV')]$Scope,
    $Target,
    [switch]$Include_Backup
)

<#
.SYNOPSIS
    This script is used to set a share or multiple shares to READ in urgency

.DESCRIPTION
    To set the shares to READ, the script got 3 Methods thanks to the "Scope" parameter
        example:
            \\BEOND01\BEON                      BEOND01         I:\Partages\BEON
            \\BEOND01\BEONTEST01                BEOND01         I:\Partages\BEONTEST01
            \\BEOND01\TestACLservice            BEOND01         I:\TestACLservice       

    Notice:
        About the target:
            - if the script is applied to the share "\\BEOND01" it will set the 3 shares above to READ
            - if you want to be more precise you can specify "\\BEOND01\BEON", only this one will be set to READ
        
        About the credentials:
            - The script needs the credential with the rights to check the AD Objects and modify the file servers. Put it in the parameter -Credentials (ex variable : $credentials = get-credential )

        About the rollback:
            - Thanks to the CSV generated by the "Set to read" Step, you can set back the old values. You just have to give the CSV to the script with the RESTORE parameter.

    
    How it works:
        If the parameter 'scope' is set to 'All', the function "Get-AllSharedFolder" will collect all the File Servers and the shares.
        If the parameter 'scope' is set to "Specific" ou "CSV", it will take the "ScopeName" as server name (ex: \\BEOND01\BEON the scopename is BEOND01)

        Once the shares are collected the script will does an 'invoke-command -asjob' foreach server. It means that all server will take incharge their own shares.
        


.EXAMPLE
    1st method : Scope Specific
        Precise the scope or scopes that you need to set in the target parameter
        command:
            $resulttab = .\Set-SharesToRead -Scope Specific -target \\BEOND01 -T1_Credentials $Credentials
            $resulttab = .\Set-SharesToRead -Scope Specific -target "\\BEOND01\TestACLService","\\BEON-SOND01" -T1_Credentials $Credentials
        

    2nd method : Scope All
        Set all shares to read but by default it exclude the backup share. To include it you have to add the parameter '-Include_Backup'
        command:
            $resulttab = .\Set-SharesToRead -Scope All -T1orT0_Credentials $Credentials -Include_BackUp


    3rd method : Scope CSV
        Set all the shares in the CSV (Notice: The file need only one column named "Share" )
        command:
            $resulttab = .\Set-SharesToRead -Scope CSV -Target ".\Template-CSV_Set-SharesToRead.csv" -Credentials $Credentials

    


    RESTORE : To restore the old shares values, you just have to give the csv generated by the "set step".
        command:
             $resulttab = .\Set-SharesToRead -Scope RollBackCSV -Target ".\Result_Set-SharesToRead_11-03-2022_15-23-00.csv" -Credentials $Credentials
        
        

.NOTES
    Author: Hakim M'SADEK

.VERSION
    Version : 1.1
#>


if(!$Credentials){
    $Credentials = Get-Credential
}

Set-location $PSScriptRoot


Function Get-AllSharedFolder{
    Param(
    $Credentials
    )

    # Array
    [System.Collections.ArrayList]$AllShares = @()

    # ClusterNodes server file 
    ((Get-ADForest).Domains | ForEach-Object {Get-Cluster -Domain $_ | Where-Object {$_ -like "*RegexToFindFileServer*"}}).Name | ForEach-Object {

        $ClusterNodes += Invoke-Command -ComputerName $_ -Credential $Credentials  {(Get-ClusterNode).Name}
    }

    # Share clusterNodes servers files
    $ClusterNodes | ForEach-Object {

        $SharesClusterNodes += Invoke-Command -ComputerName $_ -Credential $Credentials  -ErrorAction SilentlyContinue -WarningAction SilentlyContinue `
                                {Get-SmbShare | Where-Object {$_.Name -notmatch "\$|^Cluster"}}  | Select-Object ScopeName,Path,PSComputerName | Sort-Object ScopeName,Path -Unique
        if ($error[0].length -gt 0) {

            Write-host "ERROR:`t$($_)`tLigne script: $($error[0].InvocationInfo.ScriptLineNumber)`tMessage: $($error[0].Exception.Message)"
            $error.Clear() 
        } 
    }

    $SharesClusterNodes = $SharesClusterNodes | Sort ScopeName,Path  | ForEach-Object {
    
            [PSCustomObject] @{

                UNC = "\\$($_.ScopeName)$(($_.Path).substring(($_.Path).LastIndexOf("\")))"
                Name = $_.ScopeName
                Path = $_.Path
                Server = $_.PSComputerName
                            
            }

    }

    Return $SharesClusterNodes 

}

Function Set-ShareAccessRightToRead{
    param(
        [ValidateNotNullOrEmpty()]$ShareName
    )
    $ShareAccess = Get-SmbShareAccess -Name $ShareName
    foreach($Access in $ShareAccess){
        if($Access.AccessControlType -like "Allow" -and $Access.AccessRight -notlike "Read"){
            try{
                #Set Shares To READ
                Grant-SmbShareAccess -Name $ShareName -ScopeName $Access.ScopeName -AccountName $Access.AccountName -AccessRight "Read" -Force | out-null
                [Array]$ResultTab += New-Object PSObject -Property @{"Server"=$env:COMPUTERNAME; "Name"=$Access.Name; "ScopeName"=$Access.ScopeName; "AccountName"=$Access.AccountName; "AccessControlType"=$Access.AccessControlType; "OldAccessRight" = $Access.AccessRight; "NewAccessRight"="Read"; "State"="SUCCESS"; "ErrorMessage" = ""}
            }
            catch{
                [Array]$ResultTab += New-Object PSObject -Property @{"Server"=$env:COMPUTERNAME; "Name"=$Access.Name; "ScopeName"=$Access.ScopeName; "AccountName"=$Access.AccountName; "AccessControlType"=$Access.AccessControlType; "OldAccessRight" = $Access.AccessRight; "NewAccessRight"=$Access.AccessRight; "State"="FAILED"; "ErrorMessage" = $_.exception.Message}
            }
        }
        else{ #if "AccessControlType" is not set to allow or "AccessRight" is set, it doesn't have to be set
            [Array]$ResultTab += New-Object PSObject -Property @{"Server"=$env:COMPUTERNAME; "Name"=$Access.Name; "ScopeName"=$Access.ScopeName; "AccountName"=$Access.AccountName; "AccessControlType"=$Access.AccessControlType; "OldAccessRight" = $Access.AccessRight; "NewAccessRight"=$Access.AccessRight; "State"="SUCCESS"; "ErrorMessage" = ""}
        }
    }
    Return $ResultTab
}

Function Set-OldAccessRightValues{
    param(
        [ValidateNotNullOrEmpty()]$ServerShare
    )

    try{
        #Set Back Old Values
        Grant-SmbShareAccess -Name $ServerShare.Name -AccountName $ServerShare.AccountName -AccessRight $ServerShare.OldAccessRight -Force | out-null
        [Array]$ResultTab = New-Object PSObject -Property @{"Server"=$env:COMPUTERNAME; "Name"=$ServerShare.Name; "ScopeName"=$ServerShare.ScopeName; "AccountName"=$ServerShare.AccountName; "AccessControlType"=$ServerShare.AccessControlType; "OldAccessRight" = $ServerShare.OldAccessRight; "NewAccessRight"=$ServerShare.OldAccessRight; "State"="SUCCESS"; "ErrorMessage" = $_.exception.Message}
    }
    catch{
        [Array]$ResultTab = New-Object PSObject -Property @{"Server"=$env:COMPUTERNAME; "Name"=$ServerShare.Name; "ScopeName"=$ServerShare.ScopeName; "AccountName"=$ServerShare.AccountName; "AccessControlType"=$ServerShare.AccessControlType; "OldAccessRight" = $ServerShare.OldAccessRight; "NewAccessRight"=$ServerShare.NewAccessRight; "State"="FAILED"; "ErrorMessage" = $_.exception.Message}
    }

    Return $ResultTab
    
}

switch ($Scope){
    "All"{
        if($Include_BackUp){
            $SharesinAD = Get-AllSharedFolder -Credentials $Credentials
        }else{
            $SharesinAD = Get-AllSharedFolder -Credentials $Credentials | Where-Object UNC -NotLike "BackUpShare"
        }
        $SharesinAD | ForEach-Object{ [Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$_.Name;"Name"=$_.UNC.split("\")[3];"Server"=$_.server}}
       }
    "Specific"{
            if($target){
                foreach($Tar in $target){
                    if($Tar -like "\\*"){$Tar = $Tar.replace("\\","")}
                    if($Tar -like "*\") {[Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$Tar.replace("\","");"Name"=$null;"Server"=$Tar.replace("\","")}}
                    elseif($Tar -like "*0[0-9]" -and $Tar -notcontains "\"){[Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$Tar;"Name"=$null;"Server"=$Tar}}
                    elseif($Tar -like "*\*"){[Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$Tar.split("\")[0];"Name"=$Tar.split("\")[1];"Server"=$Tar.split("\")[0]}}
                    else{
                        Return Write-Host "the script doesn't understand the syntax of de $tar" -ForegroundColor Red
                    }
                }
            }
            else{
                Return (write-host "[ERROR] You have to specify a target (ex: BEOND01 or \\BEOND01\BEON)" -ForegroundColor Red)
            }
    }
    "CSV"{
        $CSV = Import-Csv -Path $target -Delimiter ";" -Encoding UTF8
        foreach ($csvline in $CSV."Share (ex: \\BEOND01\ ou BEOND01\BEON)"){
            if($csvline -like "\\*"){$csvline = $csvline.replace("\\","")}
            if($csvline -like "*\") {[Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$csvline.replace("\","");"Name"=$null;"Server"=$csvline.replace("\","")}}
            elseif($csvline -like "*0[0-9]" -and $csvline -notcontains "\"){[Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$csvline;"Name"=$null;"Server"=$csvline}}
            elseif($csvline -like "*\*"){[Array]$SharedFolders += New-Object PSObject -Property @{"ScopeName"=$csvline.split("\")[0];"Name"=$csvline.split("\")[1];"Server"=$csvline.split("\")[0]}}
            else{
                Return Write-Host "the script doesn't understand the syntax of $csvline" -ForegroundColor Red
            }
        }
    }
}



if($scope -in 'Specific','All','CSV'){
    $SetShareAccessRightToRead = "function Set-ShareAccessRightToRead{${function:Set-ShareAccessRightToRead}}"

    $Servers = $SharedFolders.server | Select-Object -unique

    ForEach($server in $servers){
        $ServerSharesFolders = $SharedFolders | Where-Object Server -like $server
        try{
            #Invoke the script on the servers
            Invoke-Command -ComputerName $server -Credential $Credentials -AsJob -ArgumentList $ServerSharesFolders,$SetShareAccessRightToRead -ScriptBlock {
                param(
                    $ServerSharesFolders,
                    $SetShareAccessRightToRead
                )

                .([ScriptBlock]::Create($SetShareAccessRightToRead))
                $SmbShares = Get-SmbShare

                foreach($ServerShareFolder in $ServerSharesFolders){
                    if(!$ServerShareFolder.Name -or $ServerShareFolder.Name -like $null -or $ServerShareFolder.Name -like ""){
                        [Array]$SharesToSet += ($SmbShares | Where-Object ScopeName -like $ServerShareFolder.ScopeName |  Where-Object Name -Notlike "*$").Name
                    }
                    else{
                        [Array]$SharesToSet += ($SmbShares | Where-Object Path -like $(($SmbShares | Where-Object Name -like $ServerShareFolder.Name).path | Select-Object -Unique) |  Where-Object Name -Notlike "*$").Name
                    }
                }
                $SharesToSet = $SharesToSet | Select-Object -Unique

                foreach ($ShareToSet in $SharesToSet){
                    [array]$ResultTab += Set-ShareAccessRightToRead -ShareName $ShareToSet
                }
        
                Return $ResultTab

            } | Out-Null
        }
        catch{
            # Add an error in $ErrorTab if the invoke-command doesn't work
            $ErrorMessage= $_.exception.message
            write-host "[ERROR] $server : $ErrorMessage"
            [array]$ErrorTab += New-Object PSObject -Property @{"Server"=$server;"ShareName"="null"; "ErrorMessage"=$ErrorMessage}
        }

    }

    #Set the path variable for the CSV at the script position
    $ExportSuccessCSV = (get-location).Path + "\Result_Set-SharesToRead.csv"
    $ExportErrorCSV = (get-location).Path + "\Error_Set-SharesToRead.csv"
}

if($Scope -like "RollBackCSV"){
    
    $SetOldAccessRightValues = "Function Set-OldAccessRightValues{${function:Set-OldAccessRightValues}}"
    $CSV = Import-Csv $target -Delimiter ";" -Encoding UTF8
    $Servers = ($CSV | Select-Object Server -Unique).server

    foreach($Server in $Servers){

        $ServerShares = $CSV | Where-Object server -like $Server
        try{
          #Invoke the script on the servers
          Invoke-Command -ComputerName $server -Credential $Credentials -AsJob -ArgumentList $ServerShares,$SetOldAccessRightValues -ScriptBlock {
              param(
                  $ServerShares,
                  $SetOldAccessRightValues
              )

              .([ScriptBlock]::Create($SetOldAccessRightValues))

              foreach($ServerShare in $ServerShares){
                  [Array]$ResultTab += Set-OldAccessRightValues -ServerShare $ServerShare
              }

              Return $ResultTab

          } | Out-Null
          catch{
            # Add an error in $ErrorTab if the invoke-command doesn't work
            $ErrorMessage= $_.exception.message
            write-host "[ERROR] $server : $ErrorMessage"
            [array]$ErrorTab += New-Object PSObject -Property @{"Server"=$server;"ShareName"="null"; "ErrorMessage"=$ErrorMessage}
        }
    }

    #Set the path variable for the CSV at the script position
    $ExportSuccessCSV = (get-location).Path + "\Result-RollBack_Set-SharesToRead.csv"
    $ExportErrorCSV = (get-location).Path + "\Error-RollBack_Set-SharesToRead.csv"
}

#Wait jobs to be done
Get-Job | Wait-job | Out-Null

#Get the results of the jobs
$result = Get-Job | Receive-Job

#Sort the property for the export
$result = $result | Select-Object "Server","ScopeName","Name","State","OldAccessRight","NewAccessRight","AccessControlType","AccountName","ErrorMessage"

#Add the the errors in the $ErrorTab
$result | Where-Object State -like Failed | ForEach-Object {[array]$ErrorTab += New-Object PSObject -Property @{"Server"=$_.server;"ShareName"=$_.Name; "ErrorMessage"=$_.ErrorMessage}}

#Succes Modification Array
$SuccessTab = $result | Where-Object State -like Success

#Set time in file
$filetime = Get-Date -Format "dd-MM-yyyy_HH-mm-ss"
$ExportSuccessCSV = $ExportSuccessCSV.replace(".csv", "_$filetime.csv")
$ExportErrorCSV =  $ExportErrorCSV.replace(".csv", "_$filetime.csv")


if(!$ErrorTab){ #if no error
    Write-host "[SUCCES] No Error Found" -ForegroundColor Green
    if($SuccessTab){ #AND contain a succes array
        Write-Host "Succes CSV here: $ExportSuccessCSV" -ForegroundColor Green
        $SuccessTab | Export-Csv -Path $ExportSuccessCSV -Delimiter ";" -Encoding UTF8 -NoTypeInformation
        Return $SuccessTab
    }
    else{ #AND no succes array found
        Write-Host "[ERROR] No Succes or error array found, the script might got an error" -ForegroundColor Red
    }
}
else{ #if got an error array

    #Count Errors, Display them and export
    $ErrorCounter = $ErrorTab.Count
    Write-Host "[ALERT] $ErrorCounter erreur(s) ont été rencontrée(s)" -ForegroundColor Red
    Write-Host "CSV d'erreur : $ExportErrorCSV" -ForegroundColor Red
    $ErrorTab | Export-Csv -Path $ExportErrorCSV -Delimiter ";" -Encoding UTF8 -NoTypeInformation

    if($SuccessTab){#AND if succes Array Found
        Write-Host "CSV de succès : $ExportSuccessCSV" -ForegroundColor Yellow
        $SuccessTab | Export-Csv -Path $ExportSuccessCSV -Delimiter ";" -Encoding UTF8 -NoTypeInformation
        Return $SuccessTab, $ErrorTab
    }
    else{ #AND if no success array found
        Return $ErrorTab
    }
}
